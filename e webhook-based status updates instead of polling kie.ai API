warning: in the working copy of 'src/app/api/videos/[id]/status/route.ts', LF will be replaced by CRLF the next time Git touches it
[1mdiff --git a/src/app/api/videos/[id]/status/route.ts b/src/app/api/videos/[id]/status/route.ts[m
[1mindex b3630ed..3cb2709 100644[m
[1m--- a/src/app/api/videos/[id]/status/route.ts[m
[1m+++ b/src/app/api/videos/[id]/status/route.ts[m
[36m@@ -1,8 +1,7 @@[m
 import { NextRequest, NextResponse } from 'next/server'[m
 import { createAdminClient } from '@/lib/supabase/admin'[m
 import { createClient } from '@/lib/supabase/server'[m
[31m-import { getTaskStatus } from '@/lib/kie'[m
[31m-import { storeVideoFromKie, getSignedVideoUrl } from '@/lib/video-storage'[m
[32m+[m[32mimport { getSignedVideoUrl } from '@/lib/video-storage'[m
 import { validateVideoQuality, shouldAutoRefund, getQualityIssuesSummary } from '@/lib/quality-validation'[m
 import { QUALITY_TIERS } from '@/lib/prompts'[m
 import { selectModelForQualityRisk, KIE_MODELS } from '@/lib/kie-models'[m
[36m@@ -140,8 +139,8 @@[m [mexport async function GET([m
     const videoDuration = (video.input_metadata as any)?.duration || undefined[m
     const createdAt = video.created_at || undefined[m
 [m
[31m-    // 6. If status is already COMPLETED or FAILED, return immediately (no external call)[m
[31m-    if (video.status === 'COMPLETED' || video.status === 'FAILED') {[m
[32m+[m[32m    // 6. If status is FAILED, return immediately (no processing needed)[m
[32m+[m[32m    if (video.status === 'FAILED') {[m
       return NextResponse.json({[m
         id: video.id,[m
         status: video.status,[m
[36m@@ -152,407 +151,277 @@[m [mexport async function GET([m
       })[m
     }[m
 [m
[31m-    // 7. If status is PROCESSING, check Kie.ai status[m
[32m+[m[32m    // 7. If status is PROCESSING, return database status (updated by webhooks)[m
[32m+[m[32m    // Webhooks handle real-time status updates from kie.ai, so we just read from DB[m
     if (video.status === 'PROCESSING') {[m
[31m-      if (!video.kie_task_id) {[m
[31m-        // Video is in PROCESSING state but has no task_id - this shouldn't happen[m
[31m-        // but we'll mark it as failed[m
[31m-        await adminClient[m
[31m-          .from('videos')[m
[31m-          .update({[m
[31m-            status: 'FAILED',[m
[31m-            error_reason: 'Video task ID is missing',[m
[31m-          })[m
[31m-          .eq('id', videoId)[m
[31m-[m
[31m-        return NextResponse.json({[m
[31m-          id: video.id,[m
[31m-          status: 'FAILED',[m
[31m-          errorReason: 'Video task ID is missing',[m
[31m-        })[m
[31m-      }[m
[32m+[m[32m      // Return current status from database (webhook updates this in real-time)[m
[32m+[m[32m      return NextResponse.json({[m
[32m+[m[32m        id: video.id,[m
[32m+[m[32m        status: 'PROCESSING',[m
[32m+[m[32m        duration: videoDuration,[m
[32m+[m[32m        createdAt,[m
[32m+[m[32m      })[m
[32m+[m[32m    }[m
 [m
[32m+[m[32m    // 8. If status is COMPLETED, check if quality validation needs to be done[m
[32m+[m[32m    // Quality validation is triggered on first status check after completion[m
[32m+[m[32m    if (video.status === 'COMPLETED' && !video.quality_validated_at && video.video_url) {[m
       try {[m
[31m-        // Call Kie.ai to check status[m
[31m-        const kieStatus = await getTaskStatus(video.kie_task_id)[m
[31m-[m
[31m-        if (kieStatus.status === 'COMPLETED' && kieStatus.videoUrl) {[m
[31m-          // Try to download and store video in Supabase Storage[m
[31m-          let storagePath: string | null = null[m
[31m-          let signedUrl: string | null = null[m
[31m-[m
[32m+[m[32m        // Get signed URL for video validation[m
[32m+[m[32m        let videoUrlForValidation = video.video_url[m
[32m+[m[32m        if (video.storage_path) {[m
           try {[m
[31m-            storagePath = await storeVideoFromKie(kieStatus.videoUrl, user.id, videoId)[m
[31m-            [m
[31m-            if (storagePath) {[m
[31m-              // Generate signed URL for the stored video[m
[31m-              signedUrl = await getSignedVideoUrl(storagePath)[m
[31m-            }[m
[31m-          } catch (storageError) {[m
[31m-            console.error('Error storing video in Supabase Storage:', storageError)[m
[31m-            // Continue with Kie.ai URL as fallback[m
[32m+[m[32m            videoUrlForValidation = await getSignedVideoUrl(video.storage_path)[m
[32m+[m[32m          } catch (urlError) {[m
[32m+[m[32m            console.error('Error getting signed URL for quality validation:', urlError)[m
[32m+[m[32m            // Fall back to original video_url[m
           }[m
[32m+[m[32m        }[m
 [m
[31m-          // Update video record with completed status, URL, and storage path[m
[31m-          const updateData: {[m
[31m-            status: 'COMPLETED'[m
[31m-            video_url: string[m
[31m-            updated_at: string[m
[31m-            storage_path?: string | null[m
[31m-          } = {[m
[31m-            status: 'COMPLETED',[m
[31m-            video_url: kieStatus.videoUrl,[m
[31m-            updated_at: new Date().toISOString(),[m
[31m-          }[m
[31m-[m
[31m-          if (storagePath) {[m
[31m-            updateData.storage_path = storagePath[m
[31m-          }[m
[31m-[m
[31m-          const { error: updateError } = await adminClient[m
[31m-            .from('videos')[m
[31m-            .update(updateData)[m
[31m-            .eq('id', videoId)[m
[31m-[m
[31m-          if (updateError) {[m
[31m-            console.error('Error updating video:', updateError)[m
[31m-            // Still return the status even if update fails[m
[31m-          }[m
[31m-[m
[31m-          // Update analytics record with completion[m
[31m-          const completedAt = new Date().toISOString()[m
[31m-          const generationTimeSeconds = createdAt [m
[31m-            ? Math.floor((new Date(completedAt).getTime() - new Date(createdAt).getTime()) / 1000)[m
[31m-            : null[m
[31m-[m
[31m-          // Note: generation_analytics table is new and may not be in TypeScript types yet[m
[31m-          const { error: analyticsError } = await adminClient[m
[31m-            .from('generation_analytics')[m
[31m-            .update({[m
[31m-              status: 'COMPLETED',[m
[31m-              completed_at: completedAt,[m
[31m-              generation_time_seconds: generationTimeSeconds,[m
[31m-            })[m
[31m-            .eq('video_id', videoId)[m
[31m-[m
[31m-          if (analyticsError) {[m
[31m-            // Log error but don't fail the request - analytics is non-critical[m
[31m-            console.error('Error updating generation analytics:', analyticsError)[m
[31m-          }[m
[32m+[m[32m        // Extract requested duration from video metadata for validation[m
[32m+[m[32m        const requestedDuration = (video.input_metadata as any)?.duration || videoDuration[m
 [m
[31m-          // 8. Post-generation quality validation[m
[31m-          try {[m
[31m-            // Extract requested duration from video metadata for validation[m
[31m-            const requestedDuration = (video.input_metadata as any)?.duration || videoDuration[m
[31m-[m
[31m-            // Validate video quality[m
[31m-            const validationResult = await validateVideoQuality([m
[31m-              signedUrl || kieStatus.videoUrl,[m
[31m-              requestedDuration,[m
[31m-              undefined, // actualDuration not available from Kie.ai response[m
[31m-              kieStatus // pass the full status response for potential metadata[m
[31m-            )[m
[31m-[m
[31m-            // Update video record with quality metrics[m
[31m-            const { error: qualityUpdateError } = await adminClient[m
[31m-              .from('videos')[m
[31m-              .update({[m
[31m-                quality_score: validationResult.sco